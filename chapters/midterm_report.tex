\section{Change of assumptions}

\section{Architecture of your module}
The module \texttt{gossip} has been developed using the Golang programming language. It relies heavily on Go features like goroutines, Go channels, and multiple Go libraries. 

\subsection{The whole picture}

As the specification requires, the \texttt{gossip} module runs as two independent protocols: one API protocol and one P2P protocol. However, these two protocols share some data to fulfill the functionality of the module. 

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{pics/structure.png}
    \caption{Structure of the gossip module}
\end{figure}

\subsubsection{1. Announce messages Go channel}

To make the announce functionality work, we need an \textbf{announce Go channel}\footnote{Marked in red in Figure 1} shared between the two protocols. Whenever the API protocol receives an announce message from another module, it processes the message immediately and sends it to the P2P protocol through this channel. The P2P protocol has an announce message handler running on a goroutine that always listens to this channel. When it receives an announce request, it will gossip this message away. 

\begin{lstlisting}
announceMsgChan := make(chan enum.AnnounceMsg)
\end{lstlisting}

\subsubsection{2. Datatype mapper}

To make the notify functionality work, we need a \textbf{datatype mapper}\footnote{Marked in blue in Figure 1} shared between two protocols. Whenever API receives a notify message, it will write the message type that is valid into the mapper and hence should be propagated further. This datatype mapper will, of course, own a mutex that guarantees there is no race condition between the two protocols.

\begin{lstlisting}
type DatatypeMapper struct {
    mutex sync.RWMutex
    data  map[net.Addr]map[enum.Datatype]bool
}
\end{lstlisting}

\subsubsection{3. Notify messages Go channel}

Thanks to the datatype mapper, the P2P protocol can recognize which kind of message it should propagate. When it receives a new message, it will check if this message type was requested by any module by reading the datatype mapper. If that is the case, it sends this message through \textbf{notify message Go channel}\footnote{Marked in orange in Figure 1}. API protocol also has a running goroutine that constantly listens to this channel. It can get those messages from P2P and send corresponding notification messages to the module requesting them. 

\subsection{API}

The API is designed to facilitate a Gossip-based protocol in a distributed system, leveraging Go's robust features for concurrency and networking. At its core, the Server listens on a specified TCP address for incoming connections, using Go's net package to manage network communications. Once a connection is accepted, the Server hands it off to a Handler, which processes messages according to their type.

The Handler utilizes a custom logger for monitoring and error reporting, enhancing the system's reliability and debuggability. It reads incoming messages, verifies their size and type using the bytes and encoding/binary packages, and then routes them to the appropriate handler functions. These functions handle specific message types such as announcements or notifications, updating the datatypeMapper, or sending messages to the announceMsgChan channel as necessary.

This seamless interaction between the Server and Handler ensures the system can efficiently process and route messages, maintaining data integrity and system state across distributed nodes. The use of Go's concurrency primitives, like goroutines and channels, allows the API to handle multiple connections simultaneously, making it scalable and robust for real-time, distributed communication.


\subsection{P2P}
\subsubsection{Bootstrapping strategy:}

Bootstrapping service is one of the important components of a P2P network that helps newly joined Node to get initial knowledge on current active peers in the network. 
In our current implementation, we use a static bootstrapping method to ensure that new nodes can join the network and connect to existing peers. The bootstrapping process involves the following steps:
\begin{enumerate}
    \item \textbf{Registration}: When a new node starts, it registers itself with the bootstrapper server. The server maintains a list of all registered peers.
    \item \textbf{Fetching Initial Peers}: After registration, the new node fetches an initial list of peers from the bootstrapper server. This list is used to establish initial connections and begin participating in the gossip protocol.
\end{enumerate}

\subsubsection{Gossip Node:}


The \texttt{GossipNode} implementation forms a critical component of our P2P VoIP application. It is designed to manage peer-to-peer communication, allowing nodes to join and leave the network, and to disseminate information efficiently. This report provides a detailed overview of the current functionalities and properties of the \texttt{GossipNode}.

\subsubsection{Functionalities}
\begin{enumerate}
    \item \textbf{Join Network}:
    \begin{itemize}
        \item \textbf{Register with Bootstrapper}: When a node starts, it registers itself with the bootstrapper server to announce its presence in the network.
        \item \textbf{Fetch Initial Peers}: After registration, the node fetches an initial list of peers from the bootstrapper server to begin establishing connections.
    \end{itemize}
    \item \textbf{Leave Network}:
    \begin{itemize}
        \item \textbf{Announce Departure}: When a node leaves the network, it announces its departure to its known peers to update their peer lists accordingly.
    \end{itemize}
    \item \textbf{Spread Information}:
    \begin{itemize}
        \item \textbf{Gossip Protocol}: The node disseminates information (such as new peers joining or leaving, and application data) using the gossip protocol. This involves sending messages to a random subset of known peers.
        \item \textbf{Handle Gossip Messages}: The node processes incoming gossip messages and forwards them to other peers, ensuring widespread distribution of information.
    \end{itemize}
    \item \textbf{Peer List Management}:
    \begin{itemize}
        \item \textbf{Periodic Peer Exchange}: Nodes periodically exchange peer lists to maintain up-to-date knowledge of the network.
        \item \textbf{Maintain Peer List}: The node maintains a list of known peers, adding new peers and removing inactive ones as necessary.
    \end{itemize}
\end{enumerate}

\subsubsection{Properties}
\begin{enumerate}
    \item \textbf{Fanout}:
    \begin{itemize}
        \item \textbf{Definition}: Fanout refers to the number of peers a node gossips to during each gossip round.
        \item \textbf{Current Setting}: The fanout is set to 2, meaning each node sends gossip messages to 2 randomly selected peers.
    \end{itemize}
    \item \textbf{Gossip Interval}:
    \begin{itemize}
        \item \textbf{Definition}: This is the interval at which periodic gossip messages are sent.
        \item \textbf{Current Setting}: The gossip interval is set to 5 seconds, ensuring regular dissemination of information.
    \end{itemize}
    \item \textbf{Message Cache}:
    \begin{itemize}
        \item \textbf{Definition}: The message cache stores recently seen messages to prevent redundant processing and forwarding.
        \item \textbf{Implementation}: The cache uses a map data structure to store message identifiers, ensuring quick lookup and efficient memory usage.
    \end{itemize}
    \item \textbf{Peers List}:
    \begin{itemize}
        \item \textbf{Definition}: The list of known peers that a node maintains to facilitate communication.
        \item \textbf{Management}: The list is updated dynamically as the node learns about new peers or detects the departure of existing peers.
    \end{itemize}
    \item \textbf{Bootstrap URL}:
    \begin{itemize}
        \item \textbf{Definition}: The URL of the bootstrapper server used for initial registration and fetching peers.
        \item \textbf{Usage}: Nodes use this URL to register themselves and to obtain an initial list of peers when they join the network.
    \end{itemize}
\end{enumerate}





\section{Security Measures}

\section{Specification of the peer-to-peer protocol that will be implemented}

\section{Future Work}

\section{Workload distributed}

\section{Effort spent for the project}